Turbo Assembler	 Version 2.01	     01/05/24 14:49:18	    Page 1
main.ASM



      1				     ; CHANGE_1
      2				     ; Вариант 8	, сделать заглавные буквы строчными
      3				     ; заменить	Y на y и Z на z
      4				     ; Так как это противоречит логике, заменим y на Y и z	на+
      5				     Z
      6	0000			     .MODEL SMALL
      7	0000			     .STACK 256
      8	0000			     .DATA
      9	0000  4F 75 72 7A 20 4E	61+  MYTEXT DB 'Ourz Native z Town with	Happy young People', 13, 10, '$' ;объявляем	    +
     10	      74 69 76 65 20 7A	20+  текстовую	переменную
     11	      54 6F 77 6E 20 77	69+
     12	      74 68 20 48 61 70	70+
     13	      79 20 79 6F 75 6E	67+
     14	      20 50 65 6F 70 6C	65+
     15	      0D 0A 24
     16				     ; 13 - возврат каретки(\r), 10 - перевод строки(\n), $ - конец +
     17				     строки
     18	      =	002A		     strlen = ($ - MYTEXT) - 3 ; длина строки MYTEXT, 7 где - 3 вычитание    +
     19				     символов (13, 10, '$')
     20
     21	002D			     .CODE
     22				     ;основная программа
     23	0000			     Start:
     24	0000  B8 0000s			 MOV AX, @DATA
     25	0003  8E D8			 MOV DS, AX ; Инициализация Data
     26
     27	0005  BA 0000r			 LEA DX, MYTEXT	; вывод исходной строки в консоль
     28	0008  B4 09			 MOV AH, 09h ;
     29	000A  CD 21			 INT 21h ;
     30
     31	000C  33 C0			 XOR AX, AX ; очищаем регистр AX
     32	000E  BB 0000r			 LEA BX, MYTEXT	; загружаем адрес	строки в	регистр BX
     33	0011  B9 002A			 MOV CX, strlen	; инициализируем счетчик CorrectHandler
     34
     35	0014			     CorrectHandler: ; функция вызывающая процедуру коррекции,   +
     36				     если символ находится в промещутке между (a-z)
     37	0014  8A 27			 MOV AH, [BX] ;	загрузка значения находящегося по	адресу+
     38				     в	регистр AH
     39
     40					 ; логика	замены y на Y и z на	Z
     41	0016  80 FC 79			 CMP AH, 79h ; сравнение значения с 'y' из ASCII таблицы
     42	0019  74 15			 JE ToUpperHandler ; Если значение меньше 'A', то увеличиваем+
     43				     счетчик каретки
     44	001B  80 FC 7A			 CMP AH, 7Ah ; сравнение значения с 'z' из ASCII таблицы
     45	001E  74 10			 JE ToUpperHandler ; Если значение меньше 'A', то увеличиваем+
     46				     счетчик каретки
     47
     48					 ; логика	перевода в строчные буквы
     49	0020  80 FC 41			 CMP AH, 41h ; сравнение значения с 'A' из ASCII таблицы
     50	0023  72 11			 JB MoveCaretCounter ; Если	значение меньше 'A', то			    +
     51				     увеличиваем счетчик каретки
     52	0025  80 FC 5A			 CMP AH, 5Ah ; сравнение значения с 'Z' из ASCII таблицы
     53	0028  77 0C			 JA MoveCaretCounter ; Если	значение больше 'Z', то			    +
     54				     увеличиваем счетчик каретки
     55	002A  E8 0018			 CALL ToLowerCase ; Попали в диапазон A-Z поэтому			    +
     56				     преобразовываем букву
     57	002D  EB 07 90			 JMP MoveCaretCounter
Turbo Assembler	 Version 2.01	     01/05/24 14:49:18	    Page 2
main.ASM



     58
     59	0030			     ToUpperHandler:
     60	0030  E8 0018			 CALL ToUpperCase
     61	0033  EB 01 90			 JMP MoveCaretCounter
     62
     63	0036			     MoveCaretCounter: ; функция	инкремента каретки данных
     64	0036  43			 INC BX
     65
     66	0037  E2 DB			 LOOP CorrectHandler ; уменьшает счетчик цикла CX и выполняет+
     67				     операцию, если	CX = 0,	то выходит из цикла
     68
     69	0039  BA 0000r			 LEA DX, MYTEXT	; вывод результирующей строки в консоль
     70	003C  B4 09			 MOV AH, 09h ;
     71	003E  CD 21			 INT 21h ;
     72
     73	0040  B8 4C00			 MOV AX, 4C00h ; завершение программы
     74	0043  CD 21			 INT 21h ;
     75
     76				     ; выставляет в единицу 6	бит регистра	AH, что		    +
     77				     превращает
     78				     ; заглавную букву в	строчную
     79	0045			     ToLowerCase PROC NEAR
     80	0045  80 CC 20			     OR	AH, 20h	; 20h -	0 0 1 0	0 0 0 0
     81	0048  88 27			     MOV [BX], AH ; записываем полученное значение
     82	004A  C3			 RET
     83	004B			     ToLowerCase ENDP
     84
     85				     ; выставляет в ноль	6 бит регистра AH, что превращает
     86				     ; строчную	букву в заглавную
     87	004B			     ToUpperCase PROC NEAR
     88	004B  80 E4 DF			     AND AH, 0DFh ; 0DFh - 1 1 0 1 1 1 1 1
     89	004E  88 27			     MOV [BX], AH ; записываем полученное значение
     90	0050  C3			 RET
     91	0051			     ToUpperCase ENDP
     92
     93				     END Start
