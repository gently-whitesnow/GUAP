https://pro.guap.ru/get-task/e9b0efe40cf3b27d0b250d75e4e09074

## Цель
Целью работы является изучение методов хеширования данных и
получение практических навыков реализации хеш-таблиц.

## Задание

Составить хеш-функцию в соответствии с заданным вариантом и
проанализировать ее. При необходимости доработать хеш-функцию.
Используя полученную хеш-функцию разработать на языке
программирования высокого уровня программу, которая должна выполнять
следующие функции:
1) создавать хеш-таблицу;
2) добавлять элементы в хеш-таблицу;
3) просматривать хеш-таблицу;
4) искать элементы в хеш-таблице по номеру сегмента/по ключу;
5) выгружать содержимое хеш-таблицы в файл для построения
гистограммы в MS Excel, или в аналогичном подходящем ПО;
6) удалять элементы из хеш-таблицы;
7) в программе должна быть реализована проверка формата
вводимого ключа;
8) при удалении элементов из хэш-таблицы, в программе должен быть
реализован алгоритм, позволяющий искать элементы, вызвавшие
коллизию с удаленным;
9) в программе должен быть реализован алгоритм, обрабатывающий
ситуации с переполнением хэш-таблицы.
Метод разрешения коллизий выбрать в соответствии с заданным
вариантом.

 
## Вариант 2021/3594 => (94 mod 25) +1 = 20

№ вар. ФорматКлюча КоличествоСегментов МетодХеширования(разрешения коллизий)
20     ццББцц      2500                Двойное хеширование

6 cимволов -> 24 бит

### Материалы https://pro.guap.ru/get-material/20c61289c9a67240d7458b1a04fb1ac4
### Лучший материал https://neerc.ifmo.ru/wiki/index.php?title=%D0%A0%D0%B0%D0%B7%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BB%D0%BB%D0%B8%D0%B7%D0%B8%D0%B9
#### 
> Детерминированность - для одного значения, один хеш
> Скорость хеширования
> Однонаправленность - зная хеш функцию, нельзя получить значение
> Лавинный эффект - при изменении байта информации, хеш полностью меняется
> Отсутствие коллизий

bcrypt = password(qwerty) + salt(1234) + cost(10)
cost - количество циклов

Хеширование - преобразование данных любой длины к данным заданной длины

Разрешение коллизий

1) Например в качестве value - связанный список (открытое хеширование)
2) Закрытое хеширование
3) Линейное опробование;
4) Квадратичное опробование;
5) Двойное хеширование


**Открытое хеширование или Метод цепочек** – это технология разрешения коллизий,
которая состоит в том, что элементы множества с равными хеш-значениями
связываются в цепочку-список. Первичные ключи – это ключи, позволяющие однозначно идентифицировать запись.
![img.png](/Users/aleksandr.z/GUAP/AlgorithmsAndDataStructures/AlgorithmsAndDataStructures/2_DataHash/images/openhash.png)

**Закрытое хеширование или Метод открытой адресации** –
При закрытом (внутреннем) хешировании в хеш-таблице хранятся непосредственно сами элементы,
а не заголовки списков элементов. Поэтому в каждой записи (сегменте) может храниться только один элемент.
При закрытом хешировании применяется методика повторного хеширования. Если осуществляется попытка
поместить элемент х в сегмент с номером h(x), который уже занят другим элементом (такая ситуация называется коллизией),
то в соответствии с методикой повторного хеширования выбирается после­довательность других номеров сегментов h1(x), h2(x), ...,
куда можно поместить элемент х. Каждое из этих местоположений последовательно проверяется, пока не будет найдено свободное. Если свободных сегментов нет, то, следовательно, таблица заполнена, и элемент х добавить нельзя.

**Линейное опробование** (рис. 29, а) сводится к последовательному
перебору сегментов таблицы с некоторым фиксированным шагом:
адрес = h(x) + c·i ,
где i – номер попытки разрешить коллизию;
c – константа, определяющая шаг перебора.
При шаге, равном единице, происходит последовательный перебор всех сегментов после текущего.

**Квадратичное** - тоже самое что и линейное, только шаг в квадрате

**Двойное хеширование** (англ. double hashing) — метод борьбы с коллизиями,
возникающими при открытой адресации, основанный на использовании двух хеш-функций для построения различных последовательностей исследования хеш-таблицы.

При двойном хешировании используются две независимые хеш-функции h1(k) и h2(k).
Пусть k — это наш ключ, m — размер нашей таблицы, nmodm — остаток от деления n на m,
тогда сначала исследуется ячейка с адресом h1(k), если она уже занята, то рассматривается (h1(k)+h2(k))modm,
затем (h1(k)+2⋅h2(k))modm и так далее. В общем случае идёт проверка последовательности ячеек (h1(k)+i⋅h2(k))modm
где i=(0,1,...,m−1)

SHA-3-256  -256 бит, 1 символ - 4 бит => 64 символа

Неплохая статья по реализации хеш таблицы
https://habr.com/ru/post/509220/

