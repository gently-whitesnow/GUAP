# Лаба по лиспу

## установка lisp на macos

[ссылка](https://www.geeksforgeeks.org/how-to-install-lisp-on-macos/)

## команды

#### компиляция и запуск

sbcl --script solution.lisp

sbcl --sysinit solution.lisp

#### интерактивный режим

sbcl

- (quit) - выход

## что необходимо для решения

- посмотреть видос
- методичка в лк

## знания для конкретного решения

---

### **1. Списки как основная структура данных**

- **Списки** в Lisp являются основной структурой данных. Они могут содержать атомы (элементы) или вложенные списки.
- Пример списка: `(1 2 3 4 5)`.

---

### **2. Функции для работы со списками**

- **`car`**: Возвращает первый элемент списка (голову).
  ```lisp
  (car '(1 2 3)) ; => 1
  (car '(1 2 3))
  ```
- **`cdr`**: Возвращает хвост списка (все элементы, кроме первого).

  ```lisp
  (cdr '(1 2 3)) ; => (2 3)
  ```

  Мой пример - \* (caddr '(1 2 3)) => 3

- **`cons`**: Создает новый список, добавляя элемент в начало существующего списка.
  ```lisp
  (cons 1 '(2 3)) ; => (1 2 3)
  ```

---

### **3. Условные операторы**

- **`cond`**: Основной оператор ветвления. Проверяет условия по порядку и выполняет первую ветку, где условие истинно.

  ```lisp
  (cond ((null list1) 1) ; Если list1 равен nil, вернется 1
  (t 0)) ; В противном случае вернется 0
  ```

Пример, когда не хотим объявлять переменную

```lisp
(cond
  ((not (boundp 'list1)) "Переменная не существует") ; Если переменная не существует
  ((null list1) 1) ; Если переменная существует и равна nil
  (t 0)) ; Для всех остальных случаев
```

- **`null`**: Проверяет, пустой ли список.

  ```lisp
  (null '()) ; => T
  (null '(1 2 3)) ; => NIL
  ```

- **`t`**: Условие по умолчанию в `cond`. Если ни одно из условий не выполнено, выполняется эта ветка.

---

### **4. Рекурсия**

- Вместо циклов в функциональном программировании используется рекурсия для обработки данных.
- Базовый случай останавливает рекурсию, а рекурсивный случай вызывает функцию с измененным входным аргументом.

Пример рекурсии:

```lisp
(defun sum-list (lst)
  (if (null lst)
      0 ; Базовый случай: пустой список
      (+ (car lst) (sum-list (cdr lst))))) ; Рекурсивный случай
```

- if используется так как тут бинарное решение TRUE/FALSE

---

### **5. Проверка равенства**

- **`equal`**: Сравнивает два значения на равенство. Подходит для проверки равенства как атомов (чисел, символов), так и структур данных, таких как списки или строки. Возвращает `t`, если значения равны, и `nil` в противном случае.
  ```lisp
  (equal 4 4) ; => T
  (equal 4 5) ; => NIL
  (equal '(1 2 3) '(1 2 3)) ; => T
  (equal '(1 2 3) '(3 2 1)) ; => NIL
  ```

---

### **6. Создание и определение функций**

- **`defun`**: Оператор для определения функций.
  ```lisp
  (defun my-function (arg1 arg2)
    (some-code))
  ```

---

### **7. Основы функционального программирования**

- **Чистые функции**: Функции, результат которых зависит только от их аргументов, без побочных эффектов.
- **Рекурсия**: Используется для обработки списков вместо циклов.
- **Композиция функций**: Результаты одной функции могут быть переданы в другую для создания цепочки операций.

---

### **Как все эти знания объединяются в коде**

Код для пересечения списков:

```lisp
(defun my-intersection (list1 list2)
  (cond
    ((null list1) nil) ; Если первый список пуст, возвращаем пустой список
    ((member (car list1) list2) ; Если `car` первого списка в `list2`, добавляем его к результату
     (cons (car list1) (my-intersection (cdr list1) list2)))
    (t (my-intersection (cdr list1) list2)))) ; Если элемента нет, продолжаем с `cdr`
```

### Операторы и их роль в коде:

1. **`defun`**: Определяет функцию `my-intersection`.
2. **`cond`**: Реализует логику выбора ветви.
3. **`null`**: Проверяет, пуст ли первый список.
4. **`member`**: Проверяет, есть ли текущий элемент первого списка во втором.
5. **`car`**: Извлекает текущий элемент из первого списка.
6. **`cdr`**: Переходит к следующему элементу первого списка.
7. **`cons`**: Добавляет элемент в начало результирующего списка.
8. **Рекурсия**: Обеспечивает обработку оставшихся элементов списка.
